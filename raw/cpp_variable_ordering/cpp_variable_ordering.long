Just a quick post that may be useful to those who code in c++. It is one of those not very obvious features of c++ which comes up when you start optimizing the code for efficiency. This, in fact, was brought up by one of my senior colleagues because he is currently doing the optimization work.<br><br>

What I wanted to share is this: the ordering in which you place member variables in the class matters. In the picture above are, at first sight, very similar dummy classes. Both have four member variables: 2 integers and 2 booleans. The only difference is the variable declaration order. Class A nicely separates integers from booleans. Class B, on the other hand, mixes up the variable types. This is a classical case when you have an existing class and a programmer just adds up the variables at the end of the class as he introduces new features.<br><br>

The problem is that the ordering of the variable types affects the way the compiler allocates memory. If we consider provided examples, one instance of class-A costs 12 bytes as the compiler tries to lump consequent boolean variables into 4 bytes. As a matter of fact, you can add two more booleans and not increase the allocated memory. The instance of class-B, however, would cost 16 bytes. I bet you already understand why. The compiler fails to group the booleans since they are not consequent. If you are using GCC, chances are you can save some memory using this trick. For this simple case we got 25% memory allocation reduction just from reordering! Not bad, isn't it? So if you work with c++ codebase, go ahead and check this right now! :)<br>
